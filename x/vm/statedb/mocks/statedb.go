// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	common "github.com/ethereum/go-ethereum/common"
	mock "github.com/stretchr/testify/mock"

	params "github.com/ethereum/go-ethereum/params"

	state "github.com/ethereum/go-ethereum/core/state"

	stateless "github.com/ethereum/go-ethereum/core/stateless"

	tracing "github.com/ethereum/go-ethereum/core/tracing"

	types "github.com/ethereum/go-ethereum/core/types"

	uint256 "github.com/holiman/uint256"

	utils "github.com/ethereum/go-ethereum/trie/utils"
)

// StateDB is an autogenerated mock type for the StateDB type
type StateDB struct {
	mock.Mock
}

// AccessEvents provides a mock function with no fields
func (_m *StateDB) AccessEvents() *state.AccessEvents {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AccessEvents")
	}

	var r0 *state.AccessEvents
	if rf, ok := ret.Get(0).(func() *state.AccessEvents); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.AccessEvents)
		}
	}

	return r0
}

// AddAddressToAccessList provides a mock function with given fields: addr
func (_m *StateDB) AddAddressToAccessList(addr common.Address) {
	_m.Called(addr)
}

// AddBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *StateDB) AddBalance(_a0 common.Address, _a1 *uint256.Int, _a2 tracing.BalanceChangeReason) uint256.Int {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for AddBalance")
	}

	var r0 uint256.Int
	if rf, ok := ret.Get(0).(func(common.Address, *uint256.Int, tracing.BalanceChangeReason) uint256.Int); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uint256.Int)
		}
	}

	return r0
}

// AddLog provides a mock function with given fields: _a0
func (_m *StateDB) AddLog(_a0 *types.Log) {
	_m.Called(_a0)
}

// AddPreimage provides a mock function with given fields: _a0, _a1
func (_m *StateDB) AddPreimage(_a0 common.Hash, _a1 []byte) {
	_m.Called(_a0, _a1)
}

// AddRefund provides a mock function with given fields: _a0
func (_m *StateDB) AddRefund(_a0 uint64) {
	_m.Called(_a0)
}

// AddSlotToAccessList provides a mock function with given fields: addr, slot
func (_m *StateDB) AddSlotToAccessList(addr common.Address, slot common.Hash) {
	_m.Called(addr, slot)
}

// AddressInAccessList provides a mock function with given fields: addr
func (_m *StateDB) AddressInAccessList(addr common.Address) bool {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		panic("no return value specified for AddressInAccessList")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Address) bool); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// CreateAccount provides a mock function with given fields: _a0
func (_m *StateDB) CreateAccount(_a0 common.Address) {
	_m.Called(_a0)
}

// CreateContract provides a mock function with given fields: _a0
func (_m *StateDB) CreateContract(_a0 common.Address) {
	_m.Called(_a0)
}

// Empty provides a mock function with given fields: _a0
func (_m *StateDB) Empty(_a0 common.Address) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Empty")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Address) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Exist provides a mock function with given fields: _a0
func (_m *StateDB) Exist(_a0 common.Address) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Exist")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Address) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Finalise provides a mock function with given fields: _a0
func (_m *StateDB) Finalise(_a0 bool) {
	_m.Called(_a0)
}

// GetBalance provides a mock function with given fields: _a0
func (_m *StateDB) GetBalance(_a0 common.Address) *uint256.Int {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 *uint256.Int
	if rf, ok := ret.Get(0).(func(common.Address) *uint256.Int); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint256.Int)
		}
	}

	return r0
}

// GetCode provides a mock function with given fields: _a0
func (_m *StateDB) GetCode(_a0 common.Address) []byte {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetCode")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func(common.Address) []byte); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetCodeHash provides a mock function with given fields: _a0
func (_m *StateDB) GetCodeHash(_a0 common.Address) common.Hash {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetCodeHash")
	}

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(common.Address) common.Hash); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	return r0
}

// GetCodeSize provides a mock function with given fields: _a0
func (_m *StateDB) GetCodeSize(_a0 common.Address) int {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetCodeSize")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func(common.Address) int); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetNonce provides a mock function with given fields: _a0
func (_m *StateDB) GetNonce(_a0 common.Address) uint64 {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetNonce")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetRefund provides a mock function with no fields
func (_m *StateDB) GetRefund() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRefund")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetState provides a mock function with given fields: _a0, _a1
func (_m *StateDB) GetState(_a0 common.Address, _a1 common.Hash) common.Hash {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetState")
	}

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(common.Address, common.Hash) common.Hash); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	return r0
}

// GetStateAndCommittedState provides a mock function with given fields: _a0, _a1
func (_m *StateDB) GetStateAndCommittedState(_a0 common.Address, _a1 common.Hash) (common.Hash, common.Hash) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetStateAndCommittedState")
	}

	var r0 common.Hash
	var r1 common.Hash
	if rf, ok := ret.Get(0).(func(common.Address, common.Hash) (common.Hash, common.Hash)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(common.Address, common.Hash) common.Hash); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Address, common.Hash) common.Hash); ok {
		r1 = rf(_a0, _a1)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(common.Hash)
		}
	}

	return r0, r1
}

// GetStorageRoot provides a mock function with given fields: addr
func (_m *StateDB) GetStorageRoot(addr common.Address) common.Hash {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageRoot")
	}

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(common.Address) common.Hash); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	return r0
}

// GetTransientState provides a mock function with given fields: addr, key
func (_m *StateDB) GetTransientState(addr common.Address, key common.Hash) common.Hash {
	ret := _m.Called(addr, key)

	if len(ret) == 0 {
		panic("no return value specified for GetTransientState")
	}

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(common.Address, common.Hash) common.Hash); ok {
		r0 = rf(addr, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	return r0
}

// HasSelfDestructed provides a mock function with given fields: _a0
func (_m *StateDB) HasSelfDestructed(_a0 common.Address) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for HasSelfDestructed")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Address) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsStorageEmpty provides a mock function with given fields: addr
func (_m *StateDB) IsStorageEmpty(addr common.Address) bool {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		panic("no return value specified for IsStorageEmpty")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Address) bool); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// PointCache provides a mock function with no fields
func (_m *StateDB) PointCache() *utils.PointCache {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PointCache")
	}

	var r0 *utils.PointCache
	if rf, ok := ret.Get(0).(func() *utils.PointCache); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.PointCache)
		}
	}

	return r0
}

// Prepare provides a mock function with given fields: rules, sender, coinbase, dest, precompiles, txAccesses
func (_m *StateDB) Prepare(rules params.Rules, sender common.Address, coinbase common.Address, dest *common.Address, precompiles []common.Address, txAccesses types.AccessList) {
	_m.Called(rules, sender, coinbase, dest, precompiles, txAccesses)
}

// RevertToSnapshot provides a mock function with given fields: _a0
func (_m *StateDB) RevertToSnapshot(_a0 int) {
	_m.Called(_a0)
}

// SelfDestruct provides a mock function with given fields: _a0
func (_m *StateDB) SelfDestruct(_a0 common.Address) uint256.Int {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SelfDestruct")
	}

	var r0 uint256.Int
	if rf, ok := ret.Get(0).(func(common.Address) uint256.Int); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uint256.Int)
		}
	}

	return r0
}

// SelfDestruct6780 provides a mock function with given fields: _a0
func (_m *StateDB) SelfDestruct6780(_a0 common.Address) (uint256.Int, bool) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SelfDestruct6780")
	}

	var r0 uint256.Int
	var r1 bool
	if rf, ok := ret.Get(0).(func(common.Address) (uint256.Int, bool)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(common.Address) uint256.Int); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uint256.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Address) bool); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// SetCode provides a mock function with given fields: _a0, _a1
func (_m *StateDB) SetCode(_a0 common.Address, _a1 []byte) []byte {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for SetCode")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func(common.Address, []byte) []byte); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// SetNonce provides a mock function with given fields: _a0, _a1, _a2
func (_m *StateDB) SetNonce(_a0 common.Address, _a1 uint64, _a2 tracing.NonceChangeReason) {
	_m.Called(_a0, _a1, _a2)
}

// SetState provides a mock function with given fields: _a0, _a1, _a2
func (_m *StateDB) SetState(_a0 common.Address, _a1 common.Hash, _a2 common.Hash) common.Hash {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for SetState")
	}

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(common.Address, common.Hash, common.Hash) common.Hash); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	return r0
}

// SetTransientState provides a mock function with given fields: addr, key, value
func (_m *StateDB) SetTransientState(addr common.Address, key common.Hash, value common.Hash) {
	_m.Called(addr, key, value)
}

// SlotInAccessList provides a mock function with given fields: addr, slot
func (_m *StateDB) SlotInAccessList(addr common.Address, slot common.Hash) (bool, bool) {
	ret := _m.Called(addr, slot)

	if len(ret) == 0 {
		panic("no return value specified for SlotInAccessList")
	}

	var r0 bool
	var r1 bool
	if rf, ok := ret.Get(0).(func(common.Address, common.Hash) (bool, bool)); ok {
		return rf(addr, slot)
	}
	if rf, ok := ret.Get(0).(func(common.Address, common.Hash) bool); ok {
		r0 = rf(addr, slot)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(common.Address, common.Hash) bool); ok {
		r1 = rf(addr, slot)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// Snapshot provides a mock function with no fields
func (_m *StateDB) Snapshot() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Snapshot")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// SubBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *StateDB) SubBalance(_a0 common.Address, _a1 *uint256.Int, _a2 tracing.BalanceChangeReason) uint256.Int {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for SubBalance")
	}

	var r0 uint256.Int
	if rf, ok := ret.Get(0).(func(common.Address, *uint256.Int, tracing.BalanceChangeReason) uint256.Int); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uint256.Int)
		}
	}

	return r0
}

// SubRefund provides a mock function with given fields: _a0
func (_m *StateDB) SubRefund(_a0 uint64) {
	_m.Called(_a0)
}

// Witness provides a mock function with no fields
func (_m *StateDB) Witness() *stateless.Witness {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Witness")
	}

	var r0 *stateless.Witness
	if rf, ok := ret.Get(0).(func() *stateless.Witness); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stateless.Witness)
		}
	}

	return r0
}

// NewStateDB creates a new instance of StateDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStateDB(t interface {
	mock.TestingT
	Cleanup(func())
}) *StateDB {
	mock := &StateDB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
