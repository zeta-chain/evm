// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"
	core "github.com/ethereum/go-ethereum/core"

	event "github.com/ethereum/go-ethereum/event"

	kzg4844 "github.com/ethereum/go-ethereum/crypto/kzg4844"

	mock "github.com/stretchr/testify/mock"

	txpool "github.com/cosmos/evm/mempool/txpool"

	types "github.com/ethereum/go-ethereum/core/types"
)

// SubPool is an autogenerated mock type for the SubPool type
type SubPool struct {
	mock.Mock
}

// Add provides a mock function with given fields: txs, sync
func (_m *SubPool) Add(txs []*types.Transaction, sync bool) []error {
	ret := _m.Called(txs, sync)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 []error
	if rf, ok := ret.Get(0).(func([]*types.Transaction, bool) []error); ok {
		r0 = rf(txs, sync)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]error)
		}
	}

	return r0
}

// Clear provides a mock function with no fields
func (_m *SubPool) Clear() {
	_m.Called()
}

// Close provides a mock function with no fields
func (_m *SubPool) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Content provides a mock function with no fields
func (_m *SubPool) Content() (map[common.Address][]*types.Transaction, map[common.Address][]*types.Transaction) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Content")
	}

	var r0 map[common.Address][]*types.Transaction
	var r1 map[common.Address][]*types.Transaction
	if rf, ok := ret.Get(0).(func() (map[common.Address][]*types.Transaction, map[common.Address][]*types.Transaction)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() map[common.Address][]*types.Transaction); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[common.Address][]*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func() map[common.Address][]*types.Transaction); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[common.Address][]*types.Transaction)
		}
	}

	return r0, r1
}

// ContentFrom provides a mock function with given fields: addr
func (_m *SubPool) ContentFrom(addr common.Address) ([]*types.Transaction, []*types.Transaction) {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		panic("no return value specified for ContentFrom")
	}

	var r0 []*types.Transaction
	var r1 []*types.Transaction
	if rf, ok := ret.Get(0).(func(common.Address) ([]*types.Transaction, []*types.Transaction)); ok {
		return rf(addr)
	}
	if rf, ok := ret.Get(0).(func(common.Address) []*types.Transaction); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Address) []*types.Transaction); ok {
		r1 = rf(addr)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*types.Transaction)
		}
	}

	return r0, r1
}

// Filter provides a mock function with given fields: tx
func (_m *SubPool) Filter(tx *types.Transaction) bool {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for Filter")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(*types.Transaction) bool); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields: hash
func (_m *SubPool) Get(hash common.Hash) *types.Transaction {
	ret := _m.Called(hash)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(common.Hash) *types.Transaction); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	return r0
}

// GetBlobs provides a mock function with given fields: vhashes
func (_m *SubPool) GetBlobs(vhashes []common.Hash) ([]*kzg4844.Blob, []*kzg4844.Proof) {
	ret := _m.Called(vhashes)

	if len(ret) == 0 {
		panic("no return value specified for GetBlobs")
	}

	var r0 []*kzg4844.Blob
	var r1 []*kzg4844.Proof
	if rf, ok := ret.Get(0).(func([]common.Hash) ([]*kzg4844.Blob, []*kzg4844.Proof)); ok {
		return rf(vhashes)
	}
	if rf, ok := ret.Get(0).(func([]common.Hash) []*kzg4844.Blob); ok {
		r0 = rf(vhashes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*kzg4844.Blob)
		}
	}

	if rf, ok := ret.Get(1).(func([]common.Hash) []*kzg4844.Proof); ok {
		r1 = rf(vhashes)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*kzg4844.Proof)
		}
	}

	return r0, r1
}

// GetMetadata provides a mock function with given fields: hash
func (_m *SubPool) GetMetadata(hash common.Hash) *txpool.TxMetadata {
	ret := _m.Called(hash)

	if len(ret) == 0 {
		panic("no return value specified for GetMetadata")
	}

	var r0 *txpool.TxMetadata
	if rf, ok := ret.Get(0).(func(common.Hash) *txpool.TxMetadata); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*txpool.TxMetadata)
		}
	}

	return r0
}

// GetRLP provides a mock function with given fields: hash
func (_m *SubPool) GetRLP(hash common.Hash) []byte {
	ret := _m.Called(hash)

	if len(ret) == 0 {
		panic("no return value specified for GetRLP")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func(common.Hash) []byte); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// Has provides a mock function with given fields: hash
func (_m *SubPool) Has(hash common.Hash) bool {
	ret := _m.Called(hash)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Init provides a mock function with given fields: gasTip, head, reserver
func (_m *SubPool) Init(gasTip uint64, head *types.Header, reserver txpool.Reserver) error {
	ret := _m.Called(gasTip, head, reserver)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, *types.Header, txpool.Reserver) error); ok {
		r0 = rf(gasTip, head, reserver)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Nonce provides a mock function with given fields: addr
func (_m *SubPool) Nonce(addr common.Address) uint64 {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		panic("no return value specified for Nonce")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// Pending provides a mock function with given fields: filter
func (_m *SubPool) Pending(filter txpool.PendingFilter) map[common.Address][]*txpool.LazyTransaction {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for Pending")
	}

	var r0 map[common.Address][]*txpool.LazyTransaction
	if rf, ok := ret.Get(0).(func(txpool.PendingFilter) map[common.Address][]*txpool.LazyTransaction); ok {
		r0 = rf(filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[common.Address][]*txpool.LazyTransaction)
		}
	}

	return r0
}

// RemoveTx provides a mock function with given fields: hash, outofbound, unreserve
func (_m *SubPool) RemoveTx(hash common.Hash, outofbound bool, unreserve bool) int {
	ret := _m.Called(hash, outofbound, unreserve)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTx")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func(common.Hash, bool, bool) int); ok {
		r0 = rf(hash, outofbound, unreserve)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Reset provides a mock function with given fields: oldHead, newHead
func (_m *SubPool) Reset(oldHead *types.Header, newHead *types.Header) {
	_m.Called(oldHead, newHead)
}

// SetGasTip provides a mock function with given fields: tip
func (_m *SubPool) SetGasTip(tip *big.Int) {
	_m.Called(tip)
}

// Stats provides a mock function with no fields
func (_m *SubPool) Stats() (int, int) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stats")
	}

	var r0 int
	var r1 int
	if rf, ok := ret.Get(0).(func() (int, int)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func() int); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// Status provides a mock function with given fields: hash
func (_m *SubPool) Status(hash common.Hash) txpool.TxStatus {
	ret := _m.Called(hash)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 txpool.TxStatus
	if rf, ok := ret.Get(0).(func(common.Hash) txpool.TxStatus); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(txpool.TxStatus)
	}

	return r0
}

// SubscribeTransactions provides a mock function with given fields: ch, reorgs
func (_m *SubPool) SubscribeTransactions(ch chan<- core.NewTxsEvent, reorgs bool) event.Subscription {
	ret := _m.Called(ch, reorgs)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeTransactions")
	}

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(chan<- core.NewTxsEvent, bool) event.Subscription); ok {
		r0 = rf(ch, reorgs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	return r0
}

// ValidateTxBasics provides a mock function with given fields: tx
func (_m *SubPool) ValidateTxBasics(tx *types.Transaction) error {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for ValidateTxBasics")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Transaction) error); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewSubPool creates a new instance of SubPool. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubPool(t interface {
	mock.TestingT
	Cleanup(func())
}) *SubPool {
	mock := &SubPool{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
